service: perkup-backend-scalable

useDotenv: true

plugins:
  - serverless-appsync-plugin
  - serverless-offline
  - serverless-plugin-warmup

provider:
  name: aws
  runtime: nodejs18.x
  region: eu-west-1
  
  # üî• OPTIMISATIONS CRITIQUES POUR 50K USERS
  environment:
    MONGO_URI: ${env:MONGO_URI}
    JWT_SECRET: ${env:JWT_SECRET}
    EMAIL_SOURCE: ${env:EMAIL_SOURCE}
    SES_REGION: ${env:SES_REGION}
    
    # Cache distribu√© Phase 3
    REDIS_CLUSTER_ENDPOINT: ${env:REDIS_CLUSTER_ENDPOINT}
    CACHE_ENABLED: true
    ENABLE_DYNAMODB_CACHE: true
    DYNAMODB_CACHE_TABLE: perkup-user-cache
    
    # Performance Phase 2 & 3
    NODE_ENV: ${env:NODE_ENV, 'development'}  # Utilise .env ou default √† development
    CONNECTION_POOL_SIZE: 100
    CACHE_STRATEGY: multi_layer
    MONITORING_ENABLED: true
    
    # Rate limiting Phase 1
    RATE_LIMIT_GLOBAL: 50000
    RATE_LIMIT_PER_USER: 1000
    
  # üöÄ IAM optimis√© pour haute performance
  iamRoleStatements:
    - Effect: Allow
      Action:
        - dynamodb:Query
        - dynamodb:GetItem
        - dynamodb:PutItem
        - dynamodb:UpdateItem
        - dynamodb:DeleteItem
        - dynamodb:BatchGetItem
        - dynamodb:BatchWriteItem
        - dynamodb:Scan
      Resource: 
        - "arn:aws:dynamodb:${self:provider.region}:*:table/perkup-*"
        - "arn:aws:dynamodb:${self:provider.region}:*:table/perkup-*/index/*"
    - Effect: Allow
      Action:
        - sqs:SendMessage
        - sqs:ReceiveMessage
        - sqs:DeleteMessage
        - sqs:GetQueueAttributes
      Resource: 
        - "arn:aws:sqs:${self:provider.region}:*:perkup-*"
    - Effect: Allow
      Action:
        - sns:Publish
        - sns:Subscribe
        - sns:Unsubscribe
      Resource: 
        - "arn:aws:sns:${self:provider.region}:*:perkup-*"
    - Effect: Allow
      Action:
        - execute-api:ManageConnections
      Resource:
        - "arn:aws:execute-api:${self:provider.region}:*:*/*/*/*"
    - Effect: Allow
      Action:
        - logs:CreateLogGroup
        - logs:CreateLogStream
        - logs:PutLogEvents
      Resource: "*"

functions:
  # üî• FONCTION GRAPHQL HAUTE PERFORMANCE (Phase 1 compl√®te)
  graphql:
    handler: src/graphqlHandler.handler  # Garde le handler existant optimis√© Phase 2
    timeout: 900  # 15 minutes
    memorySize: 3008  # Maximum pour performance
    # üöÄ PROVISIONED CONCURRENCY pour √©liminer cold starts
    provisionedConcurrency: 50  # Phase 1 compl√®te
    reservedConcurrency: 500  # Phase 1 compl√®te
    warmup:
      enabled: true
      prewarm: true
    environment:
      CONNECTION_POOL_SIZE: 100  # Phase 2
      CACHE_STRATEGY: multi_layer  # Phase 3
    events:
      - http:
          path: graphql
          method: post
          cors: true
      - http:
          path: graphql
          method: get
          cors: true
      - http:
          path: health
          method: get
          cors: true

  # üöÄ FONCTIONS ASYNC POUR TRAITEMENT LOURD (Phase 1)
  asyncProcessor:
    handler: src/handlers/async/processorHandler.handler
    timeout: 900
    memorySize: 1024
    environment:
      CONNECTION_POOL_SIZE: 50
    events:
      - sqs:
          arn: !GetAtt AsyncQueue.Arn
          batchSize: 10
          maximumBatchingWindowInSeconds: 5

  # üî• WEBSOCKET POUR TEMPS R√âEL (Phase 1)
  websocketConnect:
    handler: src/handlers/websocket/connectHandler.handler
    timeout: 30
    memorySize: 256
    events:
      - websocket:
          route: $connect
  
  websocketDisconnect:
    handler: src/handlers/websocket/disconnectHandler.handler
    timeout: 30
    memorySize: 256
    events:
      - websocket:
          route: $disconnect
          
  websocketMessage:
    handler: src/handlers/websocket/messageHandler.handler
    timeout: 30
    memorySize: 512
    events:
      - websocket:
          route: message

  # üõ°Ô∏è RATE LIMITING DISTRIBU√âE (Phase 1)
  rateLimiter:
    handler: src/handlers/security/rateLimiterHandler.handler
    timeout: 30
    memorySize: 256
    environment:
      CACHE_ENABLED: true

  # Webhook Stripe pour les abonnements (CONSERV√â)
  stripeWebhook:
    handler: src/handlers/subscription/webhookHandler.handler
    timeout: 60
    memorySize: 1024
    events:
      - http:
          path: webhook/stripe
          method: post
          cors: false

# üî• RESSOURCES AWS OPTIMIS√âES (Phase 1 compl√®te)
resources:
  Resources:
    # üöÄ DynamoDB pour cache haute performance
    UserCacheTable:
      Type: AWS::DynamoDB::Table
      Properties:
        TableName: perkup-user-cache
        BillingMode: ON_DEMAND  # Auto-scaling
        AttributeDefinitions:
          - AttributeName: cacheKey
            AttributeType: S
          - AttributeName: type
            AttributeType: S
        KeySchema:
          - AttributeName: cacheKey
            KeyType: HASH
        GlobalSecondaryIndexes:
          - IndexName: TypeIndex
            KeySchema:
              - AttributeName: type
                KeyType: HASH
            Projection:
              ProjectionType: ALL
        TimeToLiveSpecification:
          AttributeName: ttl
          Enabled: true
        PointInTimeRecoverySpecification:
          PointInTimeRecoveryEnabled: true

    # üî• SQS pour traitement asynchrone
    AsyncQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: perkup-async-queue
        VisibilityTimeoutSeconds: 960
        MessageRetentionPeriod: 1209600  # 14 jours
        DelaySeconds: 0
        ReceiveMessageWaitTimeSeconds: 20  # Long polling
        RedrivePolicy:
          deadLetterTargetArn: !GetAtt DeadLetterQueue.Arn
          maxReceiveCount: 3

    DeadLetterQueue:
      Type: AWS::SQS::Queue
      Properties:
        QueueName: perkup-dlq
        MessageRetentionPeriod: 1209600

    # üöÄ SNS pour notifications distribu√©es
    NotificationTopic:
      Type: AWS::SNS::Topic
      Properties:
        TopicName: perkup-notifications
        DisplayName: Perkup Notifications

    # üî• CloudWatch Dashboard pour monitoring
    MonitoringDashboard:
      Type: AWS::CloudWatch::Dashboard
      Properties:
        DashboardName: perkup-performance
        DashboardBody: !Sub |
          {
            "widgets": [
              {
                "type": "metric",
                "properties": {
                  "metrics": [
                    ["AWS/Lambda", "Duration", "FunctionName", "${AWS::StackName}-graphql"],
                    ["AWS/Lambda", "Errors", "FunctionName", "${AWS::StackName}-graphql"],
                    ["AWS/Lambda", "Invocations", "FunctionName", "${AWS::StackName}-graphql"]
                  ],
                  "period": 300,
                  "stat": "Average",
                  "region": "${AWS::Region}",
                  "title": "GraphQL Performance"
                }
              }
            ]
          }

    # üöÄ CloudWatch Alarms
    GraphQLErrorsAlarm:
      Type: AWS::CloudWatch::Alarm
      Properties:
        AlarmName: perkup-graphql-errors
        AlarmDescription: GraphQL function errors
        MetricName: Errors
        Namespace: AWS/Lambda
        Statistic: Sum
        Period: 300
        EvaluationPeriods: 2
        Threshold: 10
        ComparisonOperator: GreaterThanThreshold
        Dimensions:
          - Name: FunctionName
            Value: !Ref GraphqlLambdaFunction
        AlarmActions:
          - !Ref NotificationTopic

    GraphQLDurationAlarm:
      Type: AWS::CloudWatch::Alarm
      Properties:
        AlarmName: perkup-graphql-duration
        AlarmDescription: GraphQL function duration
        MetricName: Duration
        Namespace: AWS/Lambda
        Statistic: Average
        Period: 300
        EvaluationPeriods: 2
        Threshold: 10000
        ComparisonOperator: GreaterThanThreshold
        Dimensions:
          - Name: FunctionName
            Value: !Ref GraphqlLambdaFunction
        AlarmActions:
          - !Ref NotificationTopic

custom:
  # üî• WARMUP CONFIGURATION (Phase 1 compl√®te)
  warmup:
    default:
      enabled: true
      events:
        - schedule: rate(5 minutes)
      timeout: 20
      prewarm: true
      concurrency: 10
      
  # Configuration offline pour dev
  serverless-offline:
    httpPort: 4000
    
  # üöÄ APPSYNC HAUTE PERFORMANCE (Phase 1)
  appSync:
    name: perkup-api-scalable
    authentication:
      type: API_KEY  # Simplifi√© pour commencer, Cognito plus tard
    schema: schema.graphql
    
    # üî• CACHE GLOBAL ACTIV√â
    caching:
      type: SMALL  # Ou MEDIUM/LARGE selon besoins
      ttl: 300     # 5 minutes
      
    # üöÄ LOGGING COMPLET
    logging:
      level: ALL
      
    dataSources:
      # MongoDB via Lambda optimis√©e (Phase 2 + 3)
      mongoLambda:
        type: AWS_LAMBDA
        config:
          functionName: graphql
      
      # DynamoDB direct pour cache (Phase 3)
      userCache:
        type: AMAZON_DYNAMODB
        config:
          tableName: !Ref UserCacheTable

    resolvers:
      Query:
        getUser:
          dataSource: userCache
          caching:
            keys:
              - $context.arguments.id
            ttl: 300
            
      Mutation:
        createUser:
          dataSource: mongoLambda
          caching:
            keys:
              - $context.arguments.input.email
            ttl: 60

# Outputs pour r√©f√©rence (seulement en production)
# outputs:
#   GraphQLEndpoint:
#     Description: GraphQL API endpoint
#     Value: !Sub "https://${ApiGatewayRestApi}.execute-api.${AWS::Region}.amazonaws.com/${self:provider.stage}/graphql"
#     
#   WebSocketEndpoint:
#     Description: WebSocket API endpoint  
#     Value: !Sub "wss://${WebsocketsApi}.execute-api.${AWS::Region}.amazonaws.com/${self:provider.stage}"
#     
#   DynamoDBCacheTable:
#     Description: DynamoDB cache table
#     Value: !Ref UserCacheTable
#     
#   AsyncQueue:
#     Description: SQS queue for async processing
#     Value: !Ref AsyncQueue
